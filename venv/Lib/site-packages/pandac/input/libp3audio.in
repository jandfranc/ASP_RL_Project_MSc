1578930752
3 3
10 libp3audio 4 M_1l 12 panda3d.core 
90
91 16 FilterProperties 0 4 181 34 FilterProperties::FilterProperties 0 2 1 2 0
120
FilterProperties::FilterProperties(void);
inline FilterProperties::FilterProperties(FilterProperties const &) = default;

92 5 clear 0 4 181 23 FilterProperties::clear 0 1 3 42
/**
 * Removes all DSP postprocessing.
 */
42
inline void FilterProperties::clear(void);

93 11 add_lowpass 0 4 181 29 FilterProperties::add_lowpass 0 1 4 60
/**
 * Add a lowpass filter to the end of the DSP chain.
 */
92
inline void FilterProperties::add_lowpass(PN_stdfloat cutoff_freq, PN_stdfloat resonance_q);

94 12 add_highpass 0 4 181 30 FilterProperties::add_highpass 0 1 5 61
/**
 * Add a highpass filter to the end of the DSP chain.
 */
93
inline void FilterProperties::add_highpass(PN_stdfloat cutoff_freq, PN_stdfloat resonance_q);

95 8 add_echo 0 4 181 26 FilterProperties::add_echo 0 1 6 57
/**
 * Add a echo filter to the end of the DSP chain.
 */
122
inline void FilterProperties::add_echo(PN_stdfloat drymix, PN_stdfloat wetmix, PN_stdfloat delay, PN_stdfloat decayratio);

96 10 add_flange 0 4 181 28 FilterProperties::add_flange 0 1 7 59
/**
 * Add a flange filter to the end of the DSP chain.
 */
118
inline void FilterProperties::add_flange(PN_stdfloat drymix, PN_stdfloat wetmix, PN_stdfloat depth, PN_stdfloat rate);

97 11 add_distort 0 4 181 29 FilterProperties::add_distort 0 1 8 60
/**
 * Add a distort filter to the end of the DSP chain.
 */
61
inline void FilterProperties::add_distort(PN_stdfloat level);

98 13 add_normalize 0 4 181 31 FilterProperties::add_normalize 0 1 9 62
/**
 * Add a normalize filter to the end of the DSP chain.
 */
109
inline void FilterProperties::add_normalize(PN_stdfloat fadetime, PN_stdfloat threshold, PN_stdfloat maxamp);

99 11 add_parameq 0 4 181 29 FilterProperties::add_parameq 0 1 10 60
/**
 * Add a parameq filter to the end of the DSP chain.
 */
108
inline void FilterProperties::add_parameq(PN_stdfloat center_freq, PN_stdfloat bandwidth, PN_stdfloat gain);

100 14 add_pitchshift 0 4 181 32 FilterProperties::add_pitchshift 0 1 11 63
/**
 * Add a pitchshift filter to the end of the DSP chain.
 */
106
inline void FilterProperties::add_pitchshift(PN_stdfloat pitch, PN_stdfloat fftsize, PN_stdfloat overlap);

101 10 add_chorus 0 4 181 28 FilterProperties::add_chorus 0 1 12 59
/**
 * Add a chorus filter to the end of the DSP chain.
 */
171
inline void FilterProperties::add_chorus(PN_stdfloat drymix, PN_stdfloat wet1, PN_stdfloat wet2, PN_stdfloat wet3, PN_stdfloat delay, PN_stdfloat rate, PN_stdfloat depth);

102 13 add_sfxreverb 0 4 181 31 FilterProperties::add_sfxreverb 0 1 13 59
/**
 * Add a reverb filter to the end of the DSP chain.
 */
491
inline void FilterProperties::add_sfxreverb(PN_stdfloat drylevel = 0, PN_stdfloat room = -10000, PN_stdfloat roomhf = 0, PN_stdfloat decaytime = 1, PN_stdfloat decayhfratio = 0.5, PN_stdfloat reflectionslevel = -10000, PN_stdfloat reflectionsdelay = 0.020000000000000005, PN_stdfloat reverblevel = 0, PN_stdfloat reverbdelay = 0.04000000000000001, PN_stdfloat diffusion = 100, PN_stdfloat density = 100, PN_stdfloat hfreference = 5000, PN_stdfloat roomlf = 0, PN_stdfloat lfreference = 250);

103 12 add_compress 0 4 181 30 FilterProperties::add_compress 0 1 14 61
/**
 * Add a compress filter to the end of the DSP chain.
 */
131
inline void FilterProperties::add_compress(PN_stdfloat threshold, PN_stdfloat attack, PN_stdfloat release, PN_stdfloat gainmakeup);

104 14 get_class_type 0 4 181 32 FilterProperties::get_class_type 0 1 15 0
57
static TypeHandle FilterProperties::get_class_type(void);

105 4 play 0 6 183 16 AudioSound::play 0 1 16 350
// For best compatibility, set the loop_count, volume, and balance, prior to
// calling play().  You may set them while they're playing, but it's
// implementation specific whether you get the results.  - Calling play() a
// second time on the same sound before it is finished will start the sound
// again (creating a skipping or stuttering effect).
40
virtual void AudioSound::play(void) = 0;

106 4 stop 0 6 183 16 AudioSound::stop 0 1 17 0
40
virtual void AudioSound::stop(void) = 0;

107 8 set_loop 0 6 183 20 AudioSound::set_loop 0 1 18 65
// loop: false = play once; true = play forever.  inits to false.
56
virtual void AudioSound::set_loop(bool loop = true) = 0;

108 8 get_loop 0 6 183 20 AudioSound::get_loop 0 1 19 0
50
virtual bool AudioSound::get_loop(void) const = 0;

109 14 set_loop_count 0 6 183 26 AudioSound::set_loop_count 0 1 20 73
// loop_count: 0 = forever; 1 = play once; n = play n times.  inits to 1.
78
virtual void AudioSound::set_loop_count(unsigned long int loop_count = 1) = 0;

110 14 get_loop_count 0 6 183 26 AudioSound::get_loop_count 0 1 21 0
69
virtual unsigned long int AudioSound::get_loop_count(void) const = 0;

111 8 set_time 0 6 183 20 AudioSound::set_time 0 1 22 656
/**
   * Control time position within the sound, in seconds.  This is similar (in
   * concept) to the seek position within a file.  The value starts at 0.0 (the
   * default) and ends at the value given by the length() method.
   *
   * In the past, this call did nothing if the sound was currently playing, and
   * it was necessary to call play() to effect the change.  This is no longer
   * the case; the time change takes effect immediately.
   *
   * If a sound is playing, calling get_time() repeatedly will return different
   * results over time.  e.g.
   * @code
   * PN_stdfloat percent_complete = s.get_time() / s.length();
   * @endcode
   */
68
virtual void AudioSound::set_time(PN_stdfloat start_time = 0.0) = 0;

112 8 get_time 0 6 183 20 AudioSound::get_time 0 1 23 0
57
virtual PN_stdfloat AudioSound::get_time(void) const = 0;

113 10 set_volume 0 6 183 22 AudioSound::set_volume 0 1 24 45
// 0 = minimum; 1.0 = maximum.  inits to 1.0.
66
virtual void AudioSound::set_volume(PN_stdfloat volume = 1.0) = 0;

114 10 get_volume 0 6 183 22 AudioSound::get_volume 0 1 25 0
59
virtual PN_stdfloat AudioSound::get_volume(void) const = 0;

115 11 set_balance 0 6 183 23 AudioSound::set_balance 0 1 26 68
// -1.0 is hard left 0.0 is centered 1.0 is hard right inits to 0.0.
74
virtual void AudioSound::set_balance(PN_stdfloat balance_right = 0.0) = 0;

116 11 get_balance 0 6 183 23 AudioSound::get_balance 0 1 27 0
60
virtual PN_stdfloat AudioSound::get_balance(void) const = 0;

117 13 set_play_rate 0 6 183 25 AudioSound::set_play_rate 0 1 28 62
// play_rate is any positive PN_stdfloat value.  inits to 1.0.
72
virtual void AudioSound::set_play_rate(PN_stdfloat play_rate = 1.0) = 0;

118 13 get_play_rate 0 6 183 25 AudioSound::get_play_rate 0 1 29 0
62
virtual PN_stdfloat AudioSound::get_play_rate(void) const = 0;

119 10 set_active 0 6 183 22 AudioSound::set_active 0 1 30 28
// inits to manager's state.
58
virtual void AudioSound::set_active(bool flag = true) = 0;

120 10 get_active 0 6 183 22 AudioSound::get_active 0 1 31 0
52
virtual bool AudioSound::get_active(void) const = 0;

121 18 set_finished_event 0 6 183 30 AudioSound::set_finished_event 0 1 32 126
// Set (or clear) the event that will be thrown when the sound finishes
// playing.  To clear the event, pass an empty string.
74
virtual void AudioSound::set_finished_event(std::string const &event) = 0;

122 18 get_finished_event 0 6 183 30 AudioSound::get_finished_event 0 1 33 0
74
virtual std::string const &AudioSound::get_finished_event(void) const = 0;

123 8 get_name 0 6 183 20 AudioSound::get_name 0 1 34 47
// There is no set_name(), this is intentional.
64
virtual std::string const &AudioSound::get_name(void) const = 0;

124 6 length 0 6 183 18 AudioSound::length 0 1 35 35
// return: playing time in seconds.
55
virtual PN_stdfloat AudioSound::length(void) const = 0;

125 17 set_3d_attributes 0 6 183 29 AudioSound::set_3d_attributes 0 1 36 179
// Controls the position of this sound's emitter.  px, py and pz are the
// emitter's position.  vx, vy and vz are the emitter's velocity in UNITS
// PER SECOND (default: meters).
139
virtual void AudioSound::set_3d_attributes(PN_stdfloat px, PN_stdfloat py, PN_stdfloat pz, PN_stdfloat vx, PN_stdfloat vy, PN_stdfloat vz);

126 17 get_3d_attributes 0 6 183 29 AudioSound::get_3d_attributes 0 0 0
145
virtual void AudioSound::get_3d_attributes(PN_stdfloat *px, PN_stdfloat *py, PN_stdfloat *pz, PN_stdfloat *vx, PN_stdfloat *vy, PN_stdfloat *vz);

127 19 set_3d_min_distance 0 6 183 31 AudioSound::set_3d_min_distance 0 1 37 168
// Controls the distance (in units) that this sound begins to fall off.
// Also affects the rate it falls off.  Default is 1.0 CloserFaster, <1.0
// FartherSlower, >1.0
63
virtual void AudioSound::set_3d_min_distance(PN_stdfloat dist);

128 19 get_3d_min_distance 0 6 183 31 AudioSound::get_3d_min_distance 0 1 38 0
64
virtual PN_stdfloat AudioSound::get_3d_min_distance(void) const;

129 19 set_3d_max_distance 0 6 183 31 AudioSound::set_3d_max_distance 0 1 39 222
// Controls the maximum distance (in units) that this sound stops falling
// off.  The sound does not stop at that point, it just doesn't get any
// quieter.  You should rarely need to adjust this.  Default is 1000000000.0
63
virtual void AudioSound::set_3d_max_distance(PN_stdfloat dist);

130 19 get_3d_max_distance 0 6 183 31 AudioSound::get_3d_max_distance 0 1 40 0
64
virtual PN_stdfloat AudioSound::get_3d_max_distance(void) const;

131 15 get_speaker_mix 0 6 183 27 AudioSound::get_speaker_mix 0 1 41 38
// *_speaker_mix is for use with FMOD.
61
virtual PN_stdfloat AudioSound::get_speaker_mix(int speaker);

132 15 set_speaker_mix 0 6 183 27 AudioSound::set_speaker_mix 0 1 42 0
215
virtual void AudioSound::set_speaker_mix(PN_stdfloat frontleft, PN_stdfloat frontright, PN_stdfloat center, PN_stdfloat sub, PN_stdfloat backleft, PN_stdfloat backright, PN_stdfloat sideleft, PN_stdfloat sideright);

133 12 get_priority 0 6 183 24 AudioSound::get_priority 0 1 43 0
43
virtual int AudioSound::get_priority(void);

134 12 set_priority 0 6 183 24 AudioSound::set_priority 0 1 44 0
52
virtual void AudioSound::set_priority(int priority);

135 17 configure_filters 0 6 183 29 AudioSound::configure_filters 0 1 45 0
69
virtual bool AudioSound::configure_filters(FilterProperties *config);

136 6 status 0 6 183 18 AudioSound::status 0 1 46 0
67
virtual AudioSound::SoundStatus AudioSound::status(void) const = 0;

137 6 output 0 6 183 18 AudioSound::output 0 1 47 0
57
virtual void AudioSound::output(std::ostream &out) const;

138 5 write 0 6 183 17 AudioSound::write 0 1 48 0
56
virtual void AudioSound::write(std::ostream &out) const;

139 14 get_class_type 0 4 183 26 AudioSound::get_class_type 0 1 49 0
51
static TypeHandle AudioSound::get_class_type(void);

140 17 get_speaker_setup 0 6 185 31 AudioManager::get_speaker_setup 0 1 50 0
50
virtual int AudioManager::get_speaker_setup(void);

141 17 set_speaker_setup 0 6 185 31 AudioManager::set_speaker_setup 0 1 51 0
84
virtual void AudioManager::set_speaker_setup(AudioManager::SpeakerModeCategory cat);

142 17 configure_filters 0 6 185 31 AudioManager::configure_filters 0 1 52 0
71
virtual bool AudioManager::configure_filters(FilterProperties *config);

143 19 create_AudioManager 0 4 185 33 AudioManager::create_AudioManager 0 1 53 0
73
static PointerTo< AudioManager > AudioManager::create_AudioManager(void);

144 8 shutdown 0 6 185 22 AudioManager::shutdown 0 1 54 0
42
virtual void AudioManager::shutdown(void);

145 8 is_valid 0 6 185 22 AudioManager::is_valid 0 1 55 408
// If you're interested in knowing whether this audio manager is valid,
// here's the call to do it.  It is not necessary to check whether the audio
// manager is valid before making other calls.  You are free to use an
// invalid sound manager, you may get silent sounds from it though.  The
// sound manager and the sounds it creates should not crash the application
// even when the objects are not valid.
46
virtual bool AudioManager::is_valid(void) = 0;

146 9 get_sound 0 6 185 23 AudioManager::get_sound 0 2 56 57 15
// Get a sound:
300
virtual PointerTo< AudioSound > AudioManager::get_sound(Filename const &file_name, bool positional = false, int mode = ::AudioManager::SM_heuristic) = 0;
virtual PointerTo< AudioSound > AudioManager::get_sound(MovieAudio *source, bool positional = false, int mode = ::AudioManager::SM_heuristic) = 0;

147 14 get_null_sound 0 4 185 28 AudioManager::get_null_sound 0 1 58 0
59
PointerTo< AudioSound > AudioManager::get_null_sound(void);

148 13 uncache_sound 0 6 185 27 AudioManager::uncache_sound 0 1 59 278
// Tell the AudioManager there is no need to keep this one cached.  This
// doesn't break any connection between AudioSounds that have already given
// by get_sound() from this manager.  It's only affecting whether the
// AudioManager keeps a copy of the sound in its poolcache.
72
virtual void AudioManager::uncache_sound(Filename const &file_name) = 0;

149 11 clear_cache 0 6 185 25 AudioManager::clear_cache 0 1 60 0
49
virtual void AudioManager::clear_cache(void) = 0;

150 15 set_cache_limit 0 6 185 29 AudioManager::set_cache_limit 0 1 61 0
67
virtual void AudioManager::set_cache_limit(unsigned int count) = 0;

151 15 get_cache_limit 0 6 185 29 AudioManager::get_cache_limit 0 1 62 0
67
virtual unsigned int AudioManager::get_cache_limit(void) const = 0;

152 10 set_volume 0 6 185 24 AudioManager::set_volume 0 1 63 194
// Control volume: FYI: If you start a sound with the volume off and turn
// the volume up later, you'll hear the sound playing at that late point.  0
// = minimum; 1.0 = maximum.  inits to 1.0.
62
virtual void AudioManager::set_volume(PN_stdfloat volume) = 0;

153 10 get_volume 0 6 185 24 AudioManager::get_volume 0 1 64 0
61
virtual PN_stdfloat AudioManager::get_volume(void) const = 0;

154 10 set_active 0 6 185 24 AudioManager::set_active 0 1 65 364
/*
 * Turn the manager on or off.  If you play a sound while the manager is
 * inactive, it won't start.  If you deactivate the manager while sounds are
 * playing, they'll stop.  If you activate the manager while looping sounds
 * are playing (those that have a loop_count of zero), they will start playing
 * from the beginning of their loop.  inits to true.
 */
53
virtual void AudioManager::set_active(bool flag) = 0;

155 10 get_active 0 6 185 24 AudioManager::get_active 0 1 66 0
54
virtual bool AudioManager::get_active(void) const = 0;

156 26 set_concurrent_sound_limit 0 6 185 40 AudioManager::set_concurrent_sound_limit 0 1 67 343
// This controls the number of sounds that you allow at once.  This is more
// of a user choice -- it avoids talk over and the creation of a cacophony.
// It can also be used to help performance.  0 == unlimited.  1 == mutually
// exclusive (one sound at a time).  Which is an example of: n == allow n
// sounds to be playing at the same time.
82
virtual void AudioManager::set_concurrent_sound_limit(unsigned int limit = 0) = 0;

157 26 get_concurrent_sound_limit 0 6 185 40 AudioManager::get_concurrent_sound_limit 0 1 68 0
78
virtual unsigned int AudioManager::get_concurrent_sound_limit(void) const = 0;

158 24 reduce_sounds_playing_to 0 6 185 38 AudioManager::reduce_sounds_playing_to 0 1 69 369
// This is likely to be a utility function for the concurrent_sound_limit
// options.  It is exposed as an API, because it's reasonable that it may be
// useful to be here.  It reduces the number of concurrently playing sounds
// to count by some implementation specific means.  If the number of sounds
// currently playing is at or below count then there is no effect.
76
virtual void AudioManager::reduce_sounds_playing_to(unsigned int count) = 0;

159 15 stop_all_sounds 0 6 185 29 AudioManager::stop_all_sounds 0 1 70 183
// Stop playback on all sounds managed by this manager.  This is effectively
// the same as reduce_sounds_playing_to(0), but this call may be for
// efficient on some implementations.
53
virtual void AudioManager::stop_all_sounds(void) = 0;

160 6 update 0 6 185 20 AudioManager::update 0 1 71 76
// This should be called every frame.  Failure to call could cause problems.
40
virtual void AudioManager::update(void);

161 32 audio_3d_set_listener_attributes 0 6 185 46 AudioManager::audio_3d_set_listener_attributes 0 1 72 326
// This controls the "set of ears" that listens to 3D spacialized sound px,
// py, pz are position coordinates.  vx, vy, vz are a velocity vector in
// UNITS PER SECOND (default: meters). fx, fy and fz are the respective
// components of a unit forward-vector ux, uy and uz are the respective
// components of a unit up-vector
252
virtual void AudioManager::audio_3d_set_listener_attributes(PN_stdfloat px, PN_stdfloat py, PN_stdfloat pz, PN_stdfloat vx, PN_stdfloat vy, PN_stdfloat vz, PN_stdfloat fx, PN_stdfloat fy, PN_stdfloat fz, PN_stdfloat ux, PN_stdfloat uy, PN_stdfloat uz);

162 32 audio_3d_get_listener_attributes 0 6 185 46 AudioManager::audio_3d_get_listener_attributes 0 0 0
264
virtual void AudioManager::audio_3d_get_listener_attributes(PN_stdfloat *px, PN_stdfloat *py, PN_stdfloat *pz, PN_stdfloat *vx, PN_stdfloat *vy, PN_stdfloat *vz, PN_stdfloat *fx, PN_stdfloat *fy, PN_stdfloat *fz, PN_stdfloat *ux, PN_stdfloat *uy, PN_stdfloat *uz);

163 28 audio_3d_set_distance_factor 0 6 185 42 AudioManager::audio_3d_set_distance_factor 0 1 73 305
// Control the "relative scale that sets the distance factor" units for 3D
// spacialized audio. This is a float in units-per-meter. Default value is
// 1.0, which means that Panda units are understood as meters; for e.g.
// feet, set 3.28. This factor is applied only to Fmod and OpenAL at the
// moment.
76
virtual void AudioManager::audio_3d_set_distance_factor(PN_stdfloat factor);

164 28 audio_3d_get_distance_factor 0 6 185 42 AudioManager::audio_3d_get_distance_factor 0 1 74 0
75
virtual PN_stdfloat AudioManager::audio_3d_get_distance_factor(void) const;

165 27 audio_3d_set_doppler_factor 0 6 185 41 AudioManager::audio_3d_set_doppler_factor 0 1 75 123
// Control the presence of the Doppler effect.  Default is 1.0 Exaggerated
// Doppler, use >1.0 Diminshed Doppler, use <1.0
75
virtual void AudioManager::audio_3d_set_doppler_factor(PN_stdfloat factor);

166 27 audio_3d_get_doppler_factor 0 6 185 41 AudioManager::audio_3d_get_doppler_factor 0 1 76 0
74
virtual PN_stdfloat AudioManager::audio_3d_get_doppler_factor(void) const;

167 28 audio_3d_set_drop_off_factor 0 6 185 42 AudioManager::audio_3d_set_drop_off_factor 0 1 77 155
// Exaggerate or diminish the effect of distance on sound.  Default is 1.0
// Valid range is 0 to 10 Faster drop off, use >1.0 Slower drop off, use
// <1.0
76
virtual void AudioManager::audio_3d_set_drop_off_factor(PN_stdfloat factor);

168 28 audio_3d_get_drop_off_factor 0 6 185 42 AudioManager::audio_3d_get_drop_off_factor 0 1 78 0
75
virtual PN_stdfloat AudioManager::audio_3d_get_drop_off_factor(void) const;

169 16 get_dls_pathname 0 4 185 30 AudioManager::get_dls_pathname 0 1 79 0
53
static Filename AudioManager::get_dls_pathname(void);

170 6 output 0 6 185 20 AudioManager::output 0 1 80 0
59
virtual void AudioManager::output(std::ostream &out) const;

171 5 write 0 6 185 19 AudioManager::write 0 1 81 0
58
virtual void AudioManager::write(std::ostream &out) const;

172 14 get_class_type 0 4 185 28 AudioManager::get_class_type 0 1 82 0
53
static TypeHandle AudioManager::get_class_type(void);

173 16 AudioLoadRequest 0 4 190 34 AudioLoadRequest::AudioLoadRequest 0 2 83 84 118
/**
 * Create a new AudioLoadRequest, and add it to the loader via load_async(),
 * to begin an asynchronous load.
 */
205
inline explicit AudioLoadRequest::AudioLoadRequest(AudioManager *audio_manager, std::string const &filename, bool positional);
inline AudioLoadRequest::AudioLoadRequest(AudioLoadRequest const &) = default;

174 17 get_audio_manager 0 4 190 35 AudioLoadRequest::get_audio_manager 0 1 85 90
/**
 * Returns the AudioManager that will serve this asynchronous
 * AudioLoadRequest.
 */
69
inline AudioManager *AudioLoadRequest::get_audio_manager(void) const;

175 12 get_filename 0 4 190 30 AudioLoadRequest::get_filename 0 1 86 83
/**
 * Returns the filename associated with this asynchronous AudioLoadRequest.
 */
69
inline std::string const &AudioLoadRequest::get_filename(void) const;

176 14 get_positional 0 4 190 32 AudioLoadRequest::get_positional 0 1 87 93
/**
 * Returns the positional flag associated with this asynchronous
 * AudioLoadRequest.
 */
57
inline bool AudioLoadRequest::get_positional(void) const;

177 8 is_ready 0 4 190 26 AudioLoadRequest::is_ready 0 1 88 242
/**
 * Returns true if this request has completed, false if it is still pending.
 * When this returns true, you may retrieve the sound loaded by calling
 * get_sound().
 * Equivalent to `req.done() and not req.cancelled()`.
 * @see done()
 */
51
inline bool AudioLoadRequest::is_ready(void) const;

178 9 get_sound 0 4 190 27 AudioLoadRequest::get_sound 0 1 89 202
/**
 * Returns the sound that was loaded asynchronously, if any, or nullptr if
 * there was an error.  It is an error to call this unless done() returns
 * true.
 * @deprecated Use result() instead.
 */
59
inline AudioSound *AudioLoadRequest::get_sound(void) const;

179 14 get_class_type 0 4 190 32 AudioLoadRequest::get_class_type 0 1 90 0
57
static TypeHandle AudioLoadRequest::get_class_type(void);

180 17 ~AudioLoadRequest 0 4 190 35 AudioLoadRequest::~AudioLoadRequest 0 0 0
42
AudioLoadRequest::~AudioLoadRequest(void);

90
1 0 0 7 3 192 0 0 0 0 
2 0 0 7 3 192 0 0 0 1 6 param0 0 193  
3 0 0 4 4 195 0 0 42 /**
 * Removes all DSP postprocessing.
 */ 1 4 this 3 192  
4 0 0 4 5 195 0 0 60 /**
 * Add a lowpass filter to the end of the DSP chain.
 */ 3 4 this 3 192  11 cutoff_freq 1 196  11 resonance_q 1 196  
5 0 0 4 6 195 0 0 61 /**
 * Add a highpass filter to the end of the DSP chain.
 */ 3 4 this 3 192  11 cutoff_freq 1 196  11 resonance_q 1 196  
6 0 0 4 7 195 0 0 57 /**
 * Add a echo filter to the end of the DSP chain.
 */ 5 4 this 3 192  6 drymix 1 196  6 wetmix 1 196  5 delay 1 196  10 decayratio 1 196  
7 0 0 4 8 195 0 0 59 /**
 * Add a flange filter to the end of the DSP chain.
 */ 5 4 this 3 192  6 drymix 1 196  6 wetmix 1 196  5 depth 1 196  4 rate 1 196  
8 0 0 4 9 195 0 0 60 /**
 * Add a distort filter to the end of the DSP chain.
 */ 2 4 this 3 192  5 level 1 196  
9 0 0 4 10 195 0 0 62 /**
 * Add a normalize filter to the end of the DSP chain.
 */ 4 4 this 3 192  8 fadetime 1 196  9 threshold 1 196  6 maxamp 1 196  
10 0 0 4 11 195 0 0 60 /**
 * Add a parameq filter to the end of the DSP chain.
 */ 4 4 this 3 192  11 center_freq 1 196  9 bandwidth 1 196  4 gain 1 196  
11 0 0 4 12 195 0 0 63 /**
 * Add a pitchshift filter to the end of the DSP chain.
 */ 4 4 this 3 192  5 pitch 1 196  7 fftsize 1 196  7 overlap 1 196  
12 0 0 4 13 195 0 0 59 /**
 * Add a chorus filter to the end of the DSP chain.
 */ 8 4 this 3 192  6 drymix 1 196  4 wet1 1 196  4 wet2 1 196  4 wet3 1 196  5 delay 1 196  4 rate 1 196  5 depth 1 196  
13 0 0 4 14 195 0 0 59 /**
 * Add a reverb filter to the end of the DSP chain.
 */ 15 4 this 3 192  8 drylevel 1 196  4 room 1 196  6 roomhf 1 196  9 decaytime 1 196  12 decayhfratio 1 196  16 reflectionslevel 1 196  16 reflectionsdelay 1 196  11 reverblevel 1 196  11 reverbdelay 1 196  9 diffusion 1 196  7 density 1 196  11 hfreference 1 196  6 roomlf 1 196  11 lfreference 1 196  
14 0 0 4 15 195 0 0 61 /**
 * Add a compress filter to the end of the DSP chain.
 */ 5 4 this 3 192  9 threshold 1 196  6 attack 1 196  7 release 1 196  10 gainmakeup 1 196  
15 0 0 7 16 199 0 0 0 0 
16 0 0 4 18 195 0 0 350 // For best compatibility, set the loop_count, volume, and balance, prior to
// calling play().  You may set them while they're playing, but it's
// implementation specific whether you get the results.  - Calling play() a
// second time on the same sound before it is finished will start the sound
// again (creating a skipping or stuttering effect). 1 4 this 3 200  
17 0 0 4 19 195 0 0 0 1 4 this 3 200  
18 0 0 4 20 195 0 0 65 // loop: false = play once; true = play forever.  inits to false. 2 4 this 3 200  4 loop 1 201  
19 0 0 6 21 201 0 0 0 1 4 this 3 202  
20 0 0 4 22 195 0 0 73 // loop_count: 0 = forever; 1 = play once; n = play n times.  inits to 1. 2 4 this 3 200  10 loop_count 1 204  
21 0 0 6 23 204 0 0 0 1 4 this 3 202  
22 0 0 4 24 195 0 0 656 /**
   * Control time position within the sound, in seconds.  This is similar (in
   * concept) to the seek position within a file.  The value starts at 0.0 (the
   * default) and ends at the value given by the length() method.
   *
   * In the past, this call did nothing if the sound was currently playing, and
   * it was necessary to call play() to effect the change.  This is no longer
   * the case; the time change takes effect immediately.
   *
   * If a sound is playing, calling get_time() repeatedly will return different
   * results over time.  e.g.
   * @code
   * PN_stdfloat percent_complete = s.get_time() / s.length();
   * @endcode
   */ 2 4 this 3 200  10 start_time 1 196  
23 0 0 6 25 196 0 0 0 1 4 this 3 202  
24 0 0 4 26 195 0 0 45 // 0 = minimum; 1.0 = maximum.  inits to 1.0. 2 4 this 3 200  6 volume 1 196  
25 0 0 6 27 196 0 0 0 1 4 this 3 202  
26 0 0 4 28 195 0 0 68 // -1.0 is hard left 0.0 is centered 1.0 is hard right inits to 0.0. 2 4 this 3 200  13 balance_right 1 196  
27 0 0 6 29 196 0 0 0 1 4 this 3 202  
28 0 0 4 30 195 0 0 62 // play_rate is any positive PN_stdfloat value.  inits to 1.0. 2 4 this 3 200  9 play_rate 1 196  
29 0 0 6 31 196 0 0 0 1 4 this 3 202  
30 0 0 4 32 195 0 0 28 // inits to manager's state. 2 4 this 3 200  4 flag 1 201  
31 0 0 6 33 201 0 0 0 1 4 this 3 202  
32 0 0 4 34 195 0 0 126 // Set (or clear) the event that will be thrown when the sound finishes
// playing.  To clear the event, pass an empty string. 2 4 this 3 200  5 event 1 205  
33 0 0 6 35 205 0 0 0 1 4 this 3 202  
34 0 0 6 36 205 0 0 47 // There is no set_name(), this is intentional. 1 4 this 3 202  
35 0 0 6 37 196 0 0 35 // return: playing time in seconds. 1 4 this 3 202  
36 0 0 4 38 195 0 0 179 // Controls the position of this sound's emitter.  px, py and pz are the
// emitter's position.  vx, vy and vz are the emitter's velocity in UNITS
// PER SECOND (default: meters). 7 4 this 3 200  2 px 1 196  2 py 1 196  2 pz 1 196  2 vx 1 196  2 vy 1 196  2 vz 1 196  
37 0 0 4 40 195 0 0 168 // Controls the distance (in units) that this sound begins to fall off.
// Also affects the rate it falls off.  Default is 1.0 CloserFaster, <1.0
// FartherSlower, >1.0 2 4 this 3 200  4 dist 1 196  
38 0 0 6 41 196 0 0 0 1 4 this 3 202  
39 0 0 4 42 195 0 0 222 // Controls the maximum distance (in units) that this sound stops falling
// off.  The sound does not stop at that point, it just doesn't get any
// quieter.  You should rarely need to adjust this.  Default is 1000000000.0 2 4 this 3 200  4 dist 1 196  
40 0 0 6 43 196 0 0 0 1 4 this 3 202  
41 0 0 6 44 196 0 0 38 // *_speaker_mix is for use with FMOD. 2 4 this 3 200  7 speaker 1 206  
42 0 0 4 45 195 0 0 0 9 4 this 3 200  9 frontleft 1 196  10 frontright 1 196  6 center 1 196  3 sub 1 196  8 backleft 1 196  9 backright 1 196  8 sideleft 1 196  9 sideright 1 196  
43 0 0 6 46 206 0 0 0 1 4 this 3 200  
44 0 0 4 47 195 0 0 0 2 4 this 3 200  8 priority 1 206  
45 0 0 6 48 201 0 0 0 2 4 this 3 200  6 config 1 192  
46 0 0 6 50 184 0 0 0 1 4 this 3 202  
47 0 0 4 51 195 0 0 0 2 4 this 3 202  3 out 1 207  
48 0 0 4 52 195 0 0 0 2 4 this 3 202  3 out 1 207  
49 0 0 7 53 199 0 0 0 0 
50 0 0 6 58 206 0 0 0 1 4 this 3 209  
51 0 0 4 59 195 0 0 0 2 4 this 3 209  3 cat 1 186  
52 0 0 6 60 201 0 0 0 2 4 this 3 209  6 config 1 192  
53 0 0 7 61 209 0 0 0 0 
54 0 0 4 62 195 0 0 0 1 4 this 3 209  
55 0 0 6 63 201 0 0 408 // If you're interested in knowing whether this audio manager is valid,
// here's the call to do it.  It is not necessary to check whether the audio
// manager is valid before making other calls.  You are free to use an
// invalid sound manager, you may get silent sounds from it though.  The
// sound manager and the sounds it creates should not crash the application
// even when the objects are not valid. 1 4 this 3 209  
56 0 0 7 64 200 0 0 15 // Get a sound: 4 4 this 3 209  9 file_name 1 210  10 positional 1 201  4 mode 1 206  
57 0 0 7 64 200 0 0 0 4 4 this 3 209  6 source 1 212  10 positional 1 201  4 mode 1 206  
58 0 0 7 65 200 0 0 0 1 4 this 3 209  
59 0 0 4 66 195 0 0 278 // Tell the AudioManager there is no need to keep this one cached.  This
// doesn't break any connection between AudioSounds that have already given
// by get_sound() from this manager.  It's only affecting whether the
// AudioManager keeps a copy of the sound in its poolcache. 2 4 this 3 209  9 file_name 1 210  
60 0 0 4 67 195 0 0 0 1 4 this 3 209  
61 0 0 4 68 195 0 0 0 2 4 this 3 209  5 count 1 214  
62 0 0 6 69 214 0 0 0 1 4 this 3 215  
63 0 0 4 70 195 0 0 194 // Control volume: FYI: If you start a sound with the volume off and turn
// the volume up later, you'll hear the sound playing at that late point.  0
// = minimum; 1.0 = maximum.  inits to 1.0. 2 4 this 3 209  6 volume 1 196  
64 0 0 6 71 196 0 0 0 1 4 this 3 215  
65 0 0 4 72 195 0 0 364 /*
 * Turn the manager on or off.  If you play a sound while the manager is
 * inactive, it won't start.  If you deactivate the manager while sounds are
 * playing, they'll stop.  If you activate the manager while looping sounds
 * are playing (those that have a loop_count of zero), they will start playing
 * from the beginning of their loop.  inits to true.
 */ 2 4 this 3 209  4 flag 1 201  
66 0 0 6 73 201 0 0 0 1 4 this 3 215  
67 0 0 4 74 195 0 0 343 // This controls the number of sounds that you allow at once.  This is more
// of a user choice -- it avoids talk over and the creation of a cacophony.
// It can also be used to help performance.  0 == unlimited.  1 == mutually
// exclusive (one sound at a time).  Which is an example of: n == allow n
// sounds to be playing at the same time. 2 4 this 3 209  5 limit 1 214  
68 0 0 6 75 214 0 0 0 1 4 this 3 215  
69 0 0 4 76 195 0 0 369 // This is likely to be a utility function for the concurrent_sound_limit
// options.  It is exposed as an API, because it's reasonable that it may be
// useful to be here.  It reduces the number of concurrently playing sounds
// to count by some implementation specific means.  If the number of sounds
// currently playing is at or below count then there is no effect. 2 4 this 3 209  5 count 1 214  
70 0 0 4 77 195 0 0 183 // Stop playback on all sounds managed by this manager.  This is effectively
// the same as reduce_sounds_playing_to(0), but this call may be for
// efficient on some implementations. 1 4 this 3 209  
71 0 0 4 78 195 0 0 76 // This should be called every frame.  Failure to call could cause problems. 1 4 this 3 209  
72 0 0 4 79 195 0 0 326 // This controls the "set of ears" that listens to 3D spacialized sound px,
// py, pz are position coordinates.  vx, vy, vz are a velocity vector in
// UNITS PER SECOND (default: meters). fx, fy and fz are the respective
// components of a unit forward-vector ux, uy and uz are the respective
// components of a unit up-vector 13 4 this 3 209  2 px 1 196  2 py 1 196  2 pz 1 196  2 vx 1 196  2 vy 1 196  2 vz 1 196  2 fx 1 196  2 fy 1 196  2 fz 1 196  2 ux 1 196  2 uy 1 196  2 uz 1 196  
73 0 0 4 81 195 0 0 305 // Control the "relative scale that sets the distance factor" units for 3D
// spacialized audio. This is a float in units-per-meter. Default value is
// 1.0, which means that Panda units are understood as meters; for e.g.
// feet, set 3.28. This factor is applied only to Fmod and OpenAL at the
// moment. 2 4 this 3 209  6 factor 1 196  
74 0 0 6 82 196 0 0 0 1 4 this 3 215  
75 0 0 4 83 195 0 0 123 // Control the presence of the Doppler effect.  Default is 1.0 Exaggerated
// Doppler, use >1.0 Diminshed Doppler, use <1.0 2 4 this 3 209  6 factor 1 196  
76 0 0 6 84 196 0 0 0 1 4 this 3 215  
77 0 0 4 85 195 0 0 155 // Exaggerate or diminish the effect of distance on sound.  Default is 1.0
// Valid range is 0 to 10 Faster drop off, use >1.0 Slower drop off, use
// <1.0 2 4 this 3 209  6 factor 1 196  
78 0 0 6 86 196 0 0 0 1 4 this 3 215  
79 0 0 7 87 217 0 0 0 0 
80 0 0 4 90 195 0 0 0 2 4 this 3 215  3 out 1 207  
81 0 0 4 91 195 0 0 0 2 4 this 3 215  3 out 1 207  
82 0 0 7 92 199 0 0 0 0 
83 0 0 7 95 220 180 0 0 1 6 param0 0 218  
84 0 0 7 95 220 180 0 118 /**
 * Create a new AudioLoadRequest, and add it to the loader via load_async(),
 * to begin an asynchronous load.
 */ 3 13 audio_manager 1 209  8 filename 1 205  10 positional 1 201  
85 0 0 7 96 209 0 0 90 /**
 * Returns the AudioManager that will serve this asynchronous
 * AudioLoadRequest.
 */ 1 4 this 3 218  
86 0 0 6 97 205 0 0 83 /**
 * Returns the filename associated with this asynchronous AudioLoadRequest.
 */ 1 4 this 3 218  
87 0 0 6 98 201 0 0 93 /**
 * Returns the positional flag associated with this asynchronous
 * AudioLoadRequest.
 */ 1 4 this 3 218  
88 0 0 6 99 201 0 0 242 /**
 * Returns true if this request has completed, false if it is still pending.
 * When this returns true, you may retrieve the sound loaded by calling
 * get_sound().
 * Equivalent to `req.done() and not req.cancelled()`.
 * @see done()
 */ 1 4 this 3 218  
89 0 0 7 100 200 0 0 202 /**
 * Returns the sound that was loaded asynchronously, if any, or nullptr if
 * there was an error.  It is an error to call this unless done() returns
 * true.
 * @deprecated Use result() instead.
 */ 1 4 this 3 218  
90 0 0 7 101 199 0 0 0 0 
40
181 16 FilterProperties 0 75777 16 FilterProperties 16 FilterProperties 0 0 0 1 91 0 0 13 92 93 94 95 96 97 98 99 100 101 102 103 104 0 0 1 0 182 0 0 0 0 0

182 19 TypedReferenceCount 0 2048 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 410
/**
 * A base class for things which need to inherit from both TypedObject and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedObjects and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

183 10 AudioSound 0 75777 10 AudioSound 10 AudioSound 0 0 0 0 0 0 35 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 0 0 1 0 182 0 0 0 1 184 0

184 11 SoundStatus 0 794624 23 AudioSound::SoundStatus 23 AudioSound::SoundStatus 183 0 0 0 0 0 0 0 0 0 3 3 BAD 15 AudioSound::BAD 0
0 5 READY 17 AudioSound::READY 0
1 7 PLAYING 19 AudioSound::PLAYING 0
2 0 0

185 12 AudioManager 0 75777 12 AudioManager 12 AudioManager 0 0 0 0 0 1 221 33 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 0 0 1 0 182 0 0 0 3 186 187 188 0

186 19 SpeakerModeCategory 0 794624 33 AudioManager::SpeakerModeCategory 33 AudioManager::SpeakerModeCategory 185 0 0 0 0 0 0 0 0 0 9 15 SPEAKERMODE_raw 29 AudioManager::SPEAKERMODE_raw 79
// These enumerants line up one-to-one with the FMOD SPEAKERMODE
// enumerants.
0 16 SPEAKERMODE_mono 30 AudioManager::SPEAKERMODE_mono 0
1 18 SPEAKERMODE_stereo 32 AudioManager::SPEAKERMODE_stereo 0
2 16 SPEAKERMODE_quad 30 AudioManager::SPEAKERMODE_quad 0
3 20 SPEAKERMODE_surround 34 AudioManager::SPEAKERMODE_surround 0
4 19 SPEAKERMODE_5point1 33 AudioManager::SPEAKERMODE_5point1 0
5 19 SPEAKERMODE_7point1 33 AudioManager::SPEAKERMODE_7point1 0
6 15 SPEAKERMODE_max 29 AudioManager::SPEAKERMODE_max 0
7 17 SPEAKERMODE_COUNT 31 AudioManager::SPEAKERMODE_COUNT 0
8 0 0

187 9 SpeakerId 0 794624 23 AudioManager::SpeakerId 23 AudioManager::SpeakerId 185 0 0 0 0 0 0 0 0 0 10 8 SPK_none 22 AudioManager::SPK_none 0
0 13 SPK_frontleft 27 AudioManager::SPK_frontleft 0
1 14 SPK_frontright 28 AudioManager::SPK_frontright 0
2 10 SPK_center 24 AudioManager::SPK_center 0
3 7 SPK_sub 21 AudioManager::SPK_sub 0
4 12 SPK_backleft 26 AudioManager::SPK_backleft 0
5 13 SPK_backright 27 AudioManager::SPK_backright 0
6 12 SPK_sideleft 26 AudioManager::SPK_sideleft 0
7 13 SPK_sideright 27 AudioManager::SPK_sideright 0
8 9 SPK_COUNT 23 AudioManager::SPK_COUNT 0
9 0 0

188 10 StreamMode 0 794624 24 AudioManager::StreamMode 24 AudioManager::StreamMode 185 0 0 0 0 0 0 0 0 0 3 12 SM_heuristic 26 AudioManager::SM_heuristic 0
0 9 SM_sample 23 AudioManager::SM_sample 0
1 9 SM_stream 23 AudioManager::SM_stream 0
2 0 0

189 8 Filename 0 2048 8 Filename 8 Filename 0 0 0 0 0 0 0 0 0 0 0 0 550
/**
 * The name of a file, such as a texture file or an Egg file.  Stores the full
 * pathname, and includes functions for extracting out the directory prefix
 * part and the file extension and stuff.
 *
 * A Filename is also aware of the mapping between the Unix-like filename
 * convention we use internally, and the local OS's specific filename
 * convention, and it knows how to perform basic OS-specific I/O, like testing
 * for file existence and searching a searchpath, as well as the best way to
 * open an fstream for reading or writing.
 */

190 16 AudioLoadRequest 0 141313 16 AudioLoadRequest 16 AudioLoadRequest 0 0 0 1 173 180 0 6 174 175 176 177 178 179 0 0 1 0 191 0 0 0 0 300
/**
 * A class object that manages a single asynchronous audio load request.  This
 * works in conjunction with the Loader class defined in pgraph, or really
 * with any AsyncTaskManager.  Create a new AudioLoadRequest, and add it to
 * the loader via load_async(), to begin an asynchronous load.
 */

191 9 AsyncTask 0 2048 9 AsyncTask 9 AsyncTask 0 0 0 0 0 0 0 0 0 0 0 0 217
/**
 * This class represents a concrete task performed by an AsyncManager.
 * Normally, you would subclass from this class, and override do_task(), to
 * define the functionality you wish to have the task perform.
 */

192 18 FilterProperties * 0 8576 18 FilterProperties * 18 FilterProperties * 0 0 181 0 0 0 0 0 0 0 0 0 0

193 24 FilterProperties const * 0 8576 24 FilterProperties const * 24 FilterProperties const * 0 0 194 0 0 0 0 0 0 0 0 0 0

194 22 FilterProperties const 0 8832 22 FilterProperties const 22 FilterProperties const 0 0 181 0 0 0 0 0 0 0 0 0 0

195 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

196 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 197 0 0 0 0 0 0 0 0 0 0

197 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0

198 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732
/**
 * TypeHandle is the identifier used to differentiate C++ class types.  Any
 * C++ classes that inherit from some base class, and must be differentiated
 * at run time, should store a static TypeHandle object that can be queried
 * through a static member function named get_class_type().  Most of the time,
 * it is also desirable to inherit from TypedObject, which provides some
 * virtual functions to return the TypeHandle for a particular instance.
 *
 * At its essence, a TypeHandle is simply a unique identifier that is assigned
 * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
 * that ancestry of a particular type may be queried, and the type name may be
 * retrieved for run-time display.
 */

199 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 198 0 0 0 0 0 0 0 0 0 0

200 12 AudioSound * 0 8576 12 AudioSound * 12 AudioSound * 0 0 183 0 0 0 0 0 0 0 0 0 0

201 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

202 18 AudioSound const * 0 8576 18 AudioSound const * 18 AudioSound const * 0 0 203 0 0 0 0 0 0 0 0 0 0

203 16 AudioSound const 0 8832 16 AudioSound const 16 AudioSound const 0 0 183 0 0 0 0 0 0 0 0 0 0

204 17 unsigned long int 0 8214 17 unsigned long int 17 unsigned long int 0 1 0 0 0 0 0 0 0 0 0 0 0

205 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

206 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

207 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 208 0 0 0 0 0 0 0 0 0 0

208 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

209 14 AudioManager * 0 8576 14 AudioManager * 14 AudioManager * 0 0 185 0 0 0 0 0 0 0 0 0 0

210 16 Filename const * 0 8576 16 Filename const * 16 Filename const * 0 0 211 0 0 0 0 0 0 0 0 0 0

211 14 Filename const 0 8832 14 Filename const 14 Filename const 0 0 189 0 0 0 0 0 0 0 0 0 0

212 12 MovieAudio * 0 8576 12 MovieAudio * 12 MovieAudio * 0 0 213 0 0 0 0 0 0 0 0 0 0

213 10 MovieAudio 0 2048 10 MovieAudio 10 MovieAudio 0 0 0 0 0 0 0 0 0 0 0 0 397
/**
 * A MovieAudio is actually any source that provides a sequence of audio
 * samples.  That could include an AVI file, a microphone, or an internet TV
 * station.
 *
 * The difference between a MovieAudio and a MovieAudioCursor is like the
 * difference between a filename and a file handle.  The MovieAudio just
 * indicates a particular movie.  The MovieAudioCursor is what allows access.
 */

214 12 unsigned int 0 8198 12 unsigned int 12 unsigned int 0 1 0 0 0 0 0 0 0 0 0 0 0

215 20 AudioManager const * 0 8576 20 AudioManager const * 20 AudioManager const * 0 0 216 0 0 0 0 0 0 0 0 0 0

216 18 AudioManager const 0 8832 18 AudioManager const 18 AudioManager const 0 0 185 0 0 0 0 0 0 0 0 0 0

217 10 Filename * 0 8576 10 Filename * 10 Filename * 0 0 189 0 0 0 0 0 0 0 0 0 0

218 24 AudioLoadRequest const * 0 8576 24 AudioLoadRequest const * 24 AudioLoadRequest const * 0 0 219 0 0 0 0 0 0 0 0 0 0

219 22 AudioLoadRequest const 0 8832 22 AudioLoadRequest const 22 AudioLoadRequest const 0 0 190 0 0 0 0 0 0 0 0 0 0

220 18 AudioLoadRequest * 0 8576 18 AudioLoadRequest * 18 AudioLoadRequest * 0 0 190 0 0 0 0 0 0 0 0 0 0

0
1
221 12 dls_pathname 0 2 189 169 0 0 0 0 0 0 0 26 AudioManager::dls_pathname 0

0
